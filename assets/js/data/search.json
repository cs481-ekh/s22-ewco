[ { "title": "Sprint 4 Retrospective", "url": "/s22-ewco/posts/Sprint-4-Retrospective/", "categories": "Logs, Sprint Retrospective", "tags": "meeting, sprint planning", "date": "2022-04-21 08:00:00 -0600", "snippet": "Sprint Goal: Obtain approval from GWR - and with the extra time we will work on stretch features. We achieved our goal. Capacity /VelocityOur team did great wrapping up the last few things for Sprint 4 to close our project.Unforeseen technical issuesWe had some technical issues getting a publicly available demo ready for GWR, but we got it handled in time for our meeting.Tasks Completed:All tasks were completed Finish documentation and other deliverables outlined in the project plan to obtain approval. Finish class deliverables. System stats page." }, { "title": "GWR Documentation Deliverables", "url": "/s22-ewco/posts/GoWestRobotics-Documentation/", "categories": "GoWest Robotics, Documents", "tags": "gwr, documentation", "date": "2022-04-21 08:00:00 -0600", "snippet": "StatusThe basic desired functionality of the project is all up and running, the CRUD operations all work properly and thesystem logs are all stored on a centralized log file on the device. However, there are stretch goals that we were unable to accomplish for the project sponsor, such as:We were unable to figure out how to go about updating the software via USB, there is no plan in place to accomplish thatfunctionality.Separate page in the UI for displaying and searching the system logs to allow the user to view them.InstructionsThe instructions for running the application are found at the links below: Deploying on Ubuntu Deploying on FreeBSDThoughtsSome potential ideas for extending this project in future semesters: Enable robot tasks in database to actually be sent via socket to industrial machines Set up monitoring, alerting for industrial robots status Make web controller updatable via USB drive Separate page in UI for displaying/searching logs" }, { "title": "Running WebApp on Ubuntu", "url": "/s22-ewco/posts/Ubuntu-Set-up/", "categories": "Usage, Ubuntu", "tags": "ubuntu, usage", "date": "2022-04-18 08:00:00 -0600", "snippet": "To run the application from scratch, you need to follow the steps outlined below. NOTE: This application is designed to be accessed only on localhost. As such the API only listens on interface 127.0.0.1 - this is hard-coded in main.rs. Additionally, the front end sends API requests to localhost:3030, this is hardcoded in the App.vue file of each page in the UI. To serve this publicly, the API must be exposed, and listening on the right interface (0.0.0.0 for good measure).The UI also needs to be edited to send requests to the API, wherever it is hosted.Install RequirementsRustRun the following command to install Rust. Note: this command is piping the script into shcurl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | shGeneral DependenciesUse the apt package manager to install dependencies.sudo apt install -y postgresql-12 libpq-dev nginx npm build-essentialNodeJSFollow online documentation to install the latest version of NodeJS. The latest is not available from the apt.Diesel CLIDiesel is the ORM for the Rust API. Use Cargo to install Diesel CLI.cargo install diesel_cli --no-default-features --features postgresSet upRun MigrationThis command will set up the database in Postgres using the schema - assuming you are in the root directory of the application. This alsoassumes postgres is listening on port 5432 with username USER password PASSWORD and database DB_NAME.diesel migration run --migration-dir ./api/migrations --database-url postgres://USER:PASSWORD@0.0.0.0:5432/DB_NAMERun TestsAs a sanity check, run the Test suite to make sure the API is able to interact with the database. Note: Ensure the .env file in the ./api contains the proper credentials for the Postgres DB - these are what the API will use.cargo test --manifest-path ./api/Cargo.tomlClean Stale API BinariesInside the ./api folder, run the following command to clean stale binaries.cargo cleanBuild the API BinariesInside the ./api folder, use the following command to build fresh binaries.cargo buildInstall UI DependenciesInside the ./ui folder, use npm to install the UI dependencies.npm installBuild the UIInside the ./ui folder, run the UI build script.npm run buildNGINXCopy Built UI to Web-RootFrom the ./ui folder, copy the built UI files to the web-root directory of Nginx (/var/www/html).sudo cp -r ./dist/* /var/www/html/Set up Server for PagingFirst stop the server.sudo systemctl stop nginxThen add the code below to the NGINX config file /etc/nginx/sites-enabled/default inside server { }. This will allow https://localhost/statsto map to https://localhost/stats.html. Vue builds the multi-page application as different files, not different folders, so this step is necessary.location /stats { rewrite ^/stats$ stats.html;}And start the server.sudo systemctl start nginxFinally, check to make sure the configuration worked.sudo systemctl status nginxEnable NGINXsudo systemctl enable nginxRun the ApplicationRun the APIInside the ./api folder, run the API using the following command.cargo runRun the Front-EndThe front end should already be serving on port 80 if NGINX is running. To check if NGINX is running use the following command.sudo systemctl status nginxIf NGINX is running and the UI is still not reachable on port 80 this may be a firewall issue, in which case follow these steps.sudo ufw enablesudo ufw allow &#39;Nginx Full&#39;sudo ufw allow &#39;Nginx HTTP&#39;sudo ufw allow &#39;Nginx HTTPS&#39;" }, { "title": "Project Handoff", "url": "/s22-ewco/posts/Project-Handoff/", "categories": "Documentation, Handoff", "tags": "project, handoff", "date": "2022-04-18 08:00:00 -0600", "snippet": "StatusThe basic desired functionality of the project is all up and running, the CRUD operations all work properly and thesystem logs are all stored on a centralized log file on the device. However there are stretch goals that we were unable to accomplish for the project sponsor, such as:We were unable to figure out how to go about updating the software via USB, there is no plan in place to accomplish thatfunctionality.Separate page in the UI for displaying and searching the system logs to allow the user to view them.InstructionsThe instructions for running the application are found at the links below: Deploying on Ubuntu Deploying on FreeBSDThoughtsSome potential ideas for extending this project in future semesters: Enable robot tasks in database to actually be sent via socket to industrial machines Set up monitoring, alerting for industrial robots status Make web controller updatable via USB drive Separate page in UI for displaying/searching logsFuture Project IdeaExample videoWrite a game to run on the Nintendo NES, and compile it into a ROM so it can be loaded onto a console or emulator.This can be done with JavaScript and some frameworks (explained in the video above), with plain ole’ 6502 assemblyor likely many other technologies. There are fun inherent constraints in writing for an 8 bit severely resourceconstrained system (see video above). Going the JS route, the frameworks of interest are “nesly-assembler” (abstractsyntax tree to translate JS into 6502 assembly) and nesly-sound (not 100% sure what this does, but it helps createsounds that fit the constraints of the NES APU).The game ROM can be tested using JSNES - a Javascript-based Nintendo ES emulator that can be deployed in a dockercontainer. The video above explains the dev process enough to give a sense of direction, but not so much that theproject is ‘easy’ - there is still a lot of research and learning to be done." }, { "title": "Running WebApp on FreeBSD", "url": "/s22-ewco/posts/FreeBSD-Set-up/", "categories": "Usage, FreeBSD", "tags": "freebsd, usage", "date": "2022-04-18 08:00:00 -0600", "snippet": "To run the application in FreeBSD, you need to follow the steps below. Running the application in FreeBSD is much more complicatedthan running on Debian Linux distributions - these instructions assume you have familiarity with setting up FreeBSD and deploying applications.The steps for deploying in Ubuntu are similar but work much more reliably. NOTE: This application is designed to be accessed only on localhost. As such the API only listens on interface 127.0.0.1 - this is hard-coded in main.rs. Additionally, the front end sends API requests to localhost:3030, this is hardcoded in the App.vue file of each page in the UI. To serve this publicly, the API must be exposed, and listening on the right interface (0.0.0.0 for good measure).The UI also needs to be edited to send requests to the API, wherever it is hosted.Install RequirementsRustRun the following command to install Rust. Note: this command is piping the script into sh. You may have to manually add the path to the Cargo binaries toyour $PATH variable for the cargo commands to work.curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | shGeneral DependenciesUse the pkg package manager to install postgres. NOTE: Follow the FreeBSD specific instructions on initializing Postgres and enabling Postgres on boot.You will also have to set up the Postgres database and permissions. pkg install -y postgresql-13 NodeJS + npmFollow online documentation to install the latest version of NodeJS and NPM.Diesel CLIDiesel is the ORM for the Rust API. Use Cargo to install Diesel CLI.cargo install diesel_cli --no-default-features --features postgresSet upRun MigrationThis command will set up the database in Postgres using the schema - assuming you are in the root directory of the application. This alsoassumes postgres is listening on port 5432 with username USER password PASSWORD and database DB_NAME. This user and appropriate permissionsmust be set-up ahead of running the migration.diesel migration run --migration-dir ./api/migrations --database-url postgres://USER:PASSWORD@0.0.0.0:5432/DB_NAMERun TestsAs a sanity check, run the Test suite to make sure the API is able to interact with the database. Note: Ensure the .env file in the ./api contains the proper credentials for the Postgres DB - these are what the API will use when running.cargo test --manifest-path ./api/Cargo.tomlClean Stale API BinariesInside the ./api folder, run the following command to clean stale binaries.cargo cleanBuild the API BinariesInside the ./api folder, use the following command to build fresh binaries.cargo buildInstall UI DependenciesInside the ./ui folder, use npm to install the UI dependencies.npm installBuild the UIInside the ./ui folder, run the UI build script.npm run buildNGINXCopy Built UI to Web-RootFrom the ./ui folder, copy the built UI files to the web-root directory of Nginx (/usr/local/www/nginx/).cp -r ./ui/dist/* /usr/local/www/nginx/Set up Server for PagingFirst stop the server.service nginx stopThen add the code below to the NGINX config file /usr/local/etc/nginx/nginx.conf inside server { }. This will allow https://localhost/statsto map to https://localhost/stats.html. Vue builds the multi-page application as different files, not different folders, so this step is necessary.location /stats { rewrite ^/stats$ stats.html;}And start the server.service nginx reload NOTE: In addition to this, in FreeBSD you will have to change Nginx permissions accordingly to allow Nginx access to the multiple static page files.By default it will only serve index.htmlRun the ApplicationRun the APIInside the ./api folder, run the API using the following command.cargo runRun the Front-EndThe front end should already be serving on port 80 if NGINX is running. To check if NGINX is running use the following command." }, { "title": "Meeting Minutes 04/10/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-04-10/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-04-10 08:00:00 -0600", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Went over final task distribution. Discussed project handoff and completing document. Planned final deliverables.A/I: Wrap up last few issues on GitHub. Handoff project to GWR." }, { "title": "Sprint 4 Planning", "url": "/s22-ewco/posts/Sprint-4-Planning/", "categories": "Logs, Sprint Planning", "tags": "meeting, sprint planning", "date": "2022-04-04 08:00:00 -0600", "snippet": "Sprint Goal: Obtain approval from GWR - and with the extra time we will work on stretch features.Tasks: Finish documentation and other deliverables outlined in the project plan to obtain approval. Finish class deliverables. System stats page." }, { "title": "Sprint 3 Retrospective", "url": "/s22-ewco/posts/Sprint-3-Retrospective/", "categories": "Logs, Sprint Retrospective", "tags": "meeting, sprint planning", "date": "2022-04-04 08:00:00 -0600", "snippet": "Sprint Goal: Complete MVP to work on stretch goals during Sprint 4 We achieved our goal. Capacity /VelocityOur team was working at great pace this sprint, so we intend to continue in the same way with Sprint 4.Unforeseen technical issuesWe had some technical issues with our Rust API. The fact out API has to be in Rust has MASSIVELY complicated this project.We ran into CORS issues when implementing the CRUD buttons on the front-end, and it turned out to be an issue with the API, that was completely unrelated to CORS.Tasks Completed:All tasks were completed Pagination for task table. Add REST API endpoint for querying system resource usage metrics. Create Rust module for monitoring system." }, { "title": "Meeting Minutes 04/04/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-04-04/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-04-04 08:00:00 -0600", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Went over how we could obtain project approval from GWR Discussed final stretch goals Planned completion of class and project plan deliverables.A/I: Wrap up class and project plan deliverables. Complete system stats stretch goal." }, { "title": "Sprint 3 Planning", "url": "/s22-ewco/posts/Sprint-3-Planning/", "categories": "Logs, Sprint Planning", "tags": "meeting, sprint planning", "date": "2022-03-16 08:00:00 -0600", "snippet": "Sprint Goal: Complete MVP to work on stretch goals during Sprint 4Tasks: Pagination for task table Add REST API endpoint for querying system resource usage metrics Create Rust module for monitoring system" }, { "title": "Sprint 2 Retrospective", "url": "/s22-ewco/posts/Sprint-2-Retrospective/", "categories": "Logs, Sprint Retrospective", "tags": "meeting, sprint planning", "date": "2022-03-16 08:00:00 -0600", "snippet": "Sprint Goal: Have a front-end that interacts with the back-end Note: This was a vague goal from the start, but we did meet this goal with several new front-end features. Movingforward we want to be more precise with our sprint goal. Capacity /VelocityOur team was able to complete all of our tasks, so we intend to adjust our capacity accordingly to complete more tasks during Sprint 3.Unforeseen technical issuesWe had some technical issues on our CI at the very end of our Sprint. There are some inconsistencies with permissionsthat are causing errors during testing and deployment - so for sprint 3 we will re-deploy the OS on our “little computer”.TestingOur CI tests each pull request, as well as during deployment.We are having some issues with the CI deployment step during testing that are unrelated to the code quality, but we know how to fix this.Tasks Completed:All tasks were completed Added modal template for UI Added UI buttons to interact with back-end Fixed (then broke again) CI/CD Rust Logging" }, { "title": "Meeting Minutes 03/16/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-03-16/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-03-16 08:00:00 -0600", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Went over new CI approach Discussed approach for new UI layout Discussed how we plan on displaying system stats (memory, cpu usage, etc) on the UI.A/I: Figure out how to get system stats in JSON form from the API Complete all CRUD buttons on the UI. Resolve issues with CI/CD" }, { "title": "Sponsor Meeting 03/07/22", "url": "/s22-ewco/posts/Sponsor-Meeting-2022-03-07/", "categories": "Logs, Sponsor Meeting", "tags": "meeting, sponsor", "date": "2022-03-07 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, Daniel and GWRAbsent: No oneScribe: MateoItems: Met with project Sponsor Gave update on our current progress and what we are planning for sprint 2A/I: Continue UI development + add logging to backend. Check out Veutify" }, { "title": "Meeting Minutes 03/04/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-03-04/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-03-04 07:00:00 -0700", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Went over new database schema and front end design.A/I: Refactor DB date stamp code to be handled by backend without user input Get logging working Get front-end buttons working." }, { "title": "Sprint 2 Planning", "url": "/s22-ewco/posts/Sprint-2-Planning/", "categories": "Logs, Sprint Planning", "tags": "meeting, sprint planning", "date": "2022-02-28 07:00:00 -0700", "snippet": "Sprint Goal: Have a front-end that interacts with the back-end.Tasks: Various front/backend integration tasks." }, { "title": "Sprint 1 Retrospective", "url": "/s22-ewco/posts/Sprint-1-Retrospective/", "categories": "Logs, Sprint Retrospective", "tags": "meeting, sprint planning", "date": "2022-02-27 07:00:00 -0700", "snippet": "Sprint Goal: Have an MVP of front-end communicating with back end. Note: We didn’t fully meet this goal, since we still need buttons to interact with the backend from the front-end,but we have a live version of the UI ready that does communicate with the backend. Tasks Completed: Create basic front-end with Vue.js Complete CI/CD Add test cases Tasks for various back-end" }, { "title": "Meeting Minutes 02/27/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-02-27/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-02-27 07:00:00 -0700", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Went over Sprint 1, things we were struggling with, our approach for continuing development as far as collaboration and splitting workload, and planned Sprint 2.A/I: Complete Sprint 2 tasks for UI/Backend interaction." }, { "title": "Sprint 1 Planning", "url": "/s22-ewco/posts/Sprint-1-Planning/", "categories": "Logs, Sprint Planning", "tags": "meeting, sprint planning", "date": "2022-02-17 07:00:00 -0700", "snippet": "Sprint Goal: Have an MVP of front-end communicating with back end.Tasks: Create basic front-end with Vue.js Tasks for various UI components Tasks for various back-end" }, { "title": "Meeting Minutes 02/12/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-02-12/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-02-12 07:00:00 -0700", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: MateoItems: Finished GitHub CI/CD for pull requestsA/I: Continue working on backend" }, { "title": "Meeting Minutes 02/07/2022", "url": "/s22-ewco/posts/Meeting-Minutes-2022-02-06/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-02-07 07:00:00 -0700", "snippet": "Present: Daniel, Mateo, DevynAbsent: No oneScribe: DevynItems:-Finished the Project Plan final DraftA/I: Finish writing the rest of the endpoints in the REST api" }, { "title": "Sponsor Meeting 02/07/22", "url": "/s22-ewco/posts/Sponsor-Meeting-2022-02-07/", "categories": "Logs, Sponsor Meeting", "tags": "meeting, sponsor", "date": "2022-02-06 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, Daniel and GWRAbsent: No oneScribe: MateoItems: Met with project Sponsor Gave update on our current progress and GWR gave us some pointers as we head into the development part of our project.A/I: Set up CI/CD and continue API development." }, { "title": "Meeting Minutes 01/24/22", "url": "/s22-ewco/posts/Meeting-Minutes-2022-01-24/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-01-24 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, DanielAbsent: No oneScribe: MateoItems: Met with project Sponsor Covered topics specified in the “Initial Sponsor Meeting” postA/I: Read up on technologies proposed by product Sponsor (outlined in “HMI Kiosk Problem Statement” post)." }, { "title": "Initial Sponsor Meeting", "url": "/s22-ewco/posts/Initial-Sponsor-Meeting-2022-01-24/", "categories": "Logs, Sponsor Meeting", "tags": "meeting, sponsor", "date": "2022-01-24 07:00:00 -0700", "snippet": "Questions for Sponsor MeetingWe present:: Our understanding of the problem from reading the PDF shared Demo OnLogic streaming Kiosk mode on https://localhost:8443 over SSH Getting context: Walk through project requirements and starter code (if applicable) At a high level, what is the expectation of the finished product? What is the starting point (existing code)? Technologies chosen (why?): PostgreSQL Flexibility with technologies (do we need a full Postgres db or can we use a lighter weight option like Redis) Warp Web server (vs Nginx) Tech considered? Containerized micro services FreeBSD jails What do the APIs do? Any initial thoughts / ideas or known areas of bloat we can look into? Feature Prioritization: Views System diagnostics System maintenance Data/operations Security: Should web UI be accessible from network. Over HTTP/HTTPS and/or stream SSH? Do changes on one client need to be reflected on all other clients Are APIs exposed? API auth? Updates over USB would require privilege escalation Users/login: LDAP/AD? Or root account? Set-Up Tips: FreeBSD amd64 vs i386? Dev process + CI/CD Our tentative approach: Various FreeBSD VMs exposed SSH GitHub Actions build code Deploy to unconstrained FreeBSD VM Communication How often to check in? email, zoom, slack etc.? Do you want access to the test env VMs?" }, { "title": "Meeting Minutes 01/22/22", "url": "/s22-ewco/posts/Meeting-Minutes-2022-01-22/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-01-22 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, DanielAbsent: No oneScribe: MateoItems: Completed project plan draft Wrote down a tentative agenda for the sponsor meeting Compiled a list of questions to ask in the sponsor meetingA/I: Read up on technologies proposed by product Sponsor (outlined in “HMI Kiosk Problem Statement” post)." }, { "title": "FreeBSD Usage", "url": "/s22-ewco/posts/FreeBSD-Usage/", "categories": "Usage, FreeBSD", "tags": "freebsd, usage", "date": "2022-01-22 07:00:00 -0700", "snippet": "Auto login on FreeBSDBy default, FreeBSD will prompt for user login after booting up. Since the product sponsorwants the web UI to be available immediately upon booting the device, we will needto auto login a user on startup, then use a chron job to tell Xorg to stream firefoxin Kiosk mode into the CLI.The first step to auto login is to edit the gettytab file located at /etc/gettytab.**Assuming the auto login username is usr, run the following commands as root to appendnew lines to the /etc/gettytab file.echo &quot;# autologin&quot; &amp;gt;&amp;gt; /etc/gettytabecho &quot;usr:\\&quot; &amp;gt;&amp;gt; /etc/gettytabecho &quot; :ht:np:sp#115200:al=usr:&quot; &amp;gt;&amp;gt; /etc/gettytab Note: The console that is seen on the physical display is ttyv0. This console along with anyother virtual ones are defined in /etc/ttys.Lastly, specify which console the user should auto log in to. For this, edit the ttys file in /etc. Change ttyvoto specify the login username instead of Pc.console none unknown off secure#ttyv0 &quot;/usr/libexec/getty usr&quot; xterm onifexists secure# Virtual terminalsttyv1 &quot;/usr/libexec/getty Pc&quot; xterm onifexists secure...Now reboot the device and you should automatically be logged into the user specified above(on ‘ttyv0’/the display connected)." }, { "title": "FreeBSD Industrial HMI Kiosk", "url": "/s22-ewco/posts/HMI-Kiosk-Problem-Statement/", "categories": "GoWest Robotics, Documents", "tags": "documents, problem, statement", "date": "2022-01-20 22:01:00 -0700", "snippet": "BackgroundGo West RoboticsGo West Robotics is a Boise-based robotics software company. The company writes software for avariety of robotics applications, spanning from Industrial Automation (Manufacturing / Warehouseautomation) to Autonomous Mobile Robots (Self Driving Vehicles, Logistics, Construction, etc.). Go Westspecializes in the application of modern/mainstream software development to robotics applications,using widely used open source platforms such as Linux, Python, C/C++, NodeJs and Rust. Applicationsvary from algorithm development and sensor fusion to robot motion planning and robotic hardwareintegration.Industrial PCsFanless Industrial PCs are x64 compatible hardware in an industrial grade enclosure and formfactor. They are basically small and indestructible PCs with some industry specific IO. Thesecan run Linux much the same as a regular laptop, although specs are often on the low end tokeep them affordable, with a price range between $200 - $1000. For this project we aim forthe lower end of that spectrum, to end up with a system that is capable on all platforms. Thereference hardware for this project is the OnLogic CL200g-11, which has an Intel CeleronN3350 and 1GB of RAMHMI KioskMost Industrial Automation lines will need user interaction on the factory floor. Traditionally these areclunky interfaces built into some proprietary device (PLCs). Because we write our logic for ourinstallations on Linux platforms, it makes much more sense to use modern web or mobile technologiesto create fast, beautiful and highly usable user interfaces. These are not cloud connected, and runstand-alone on a closed local network. They need to be simple to install (few components anddependencies) and be quickly debuggable on site. At the same time, these systems need to be secure:factory personnel should not be able to get out of the web interface or have access to any part of thebackend system.FreeBSDFreeBSD is a secure lightweight OS. The BSD kernel is a fork from the traditional Linux kerneland very carefully managed in terms of security and bloat. Small size and security make it agood choice for a kiosk HMI. Unlike OpenBSD or roll-your own Yocto Linux builds, FreeBSD releases are full featured enough to run modern languages like Rust and a browser like Firefox,while having well-tested and understood releases with a community to help with challenges.RustRust is a fast and safe compiled language resulting in a single binary application withoutdependencies. These are all essential for the kiosk: Fast: the kiosk runs on a low resource platform. CPU and memory resources must beused wisely Safe: Unlike C or C++, memory corruption is practically impossible with Rust, makinghard to find bugs in production much less likely. Compiled: The Rust compiler is pedantic and makes it hard to have simple mistakesmake it through the compilation process. Compared to interpreted languages like Pythonand NodeJs, this greatly reduces the opportunity for runtime errors Single Binary: Deployment without internet can be cumbersome especially forlanguages with complex package management such as Python and NodeJs. Rustbinaries are fully self-contained and run without the need to install additional runtimelibraries, making deployment simple and providing ease of versioning. Project DescriptionProblem StatementGo West Robotics deploys HMIs to industrial environments for a number of clients. To keep the costdown, we need to be able to use fairly simple hardware, while still offering state of the art UIs.Oftentimes, these systems are air gapped from the internet, and so installations must be fast and simple.Upgrades may happen over USB or SSH from a directly connected laptop, again without internet; therecan be no reliance on package or source code repositories.The HMIs serve a backend system that may run on the same hardware. This brings the requirement for a(relational) database and a webserver process to serve the frontend. Our preference for the frontend isVue.js, but other options can be explored, especially if performance is improved without compromisingquality.Using a full desktop Linux such as Ubuntu or Manjaro brings in more than the small hardware footprintcan handle. Using backend languages like Node and Python cause upgrade and versioning nightmares,while posing an IP security problem when code is in plaintext on the device.Desired SolutionGo West would like to have a proof of concept for a lightweight OS and webserver running on smallfootprint hardware; a Celeron CPU with 1GB RAM. This should be enough to run a FireFox browser inkiosk mode, without installing a desktop environment. For the OS we would like to use FreeBSD and a frontend written in Vue.js. The backend webserver runs on the same machine and iswritten in Rust; we recommend ‘Warp’. It should communicate with a PostgreSQL Database using theDiesel library.Resources: Rust Diesel: https://diesel.rs/guides/getting-started Warp web server framework: https://github.com/seanmonstar/warp FireFox Kiosk Mode: https://support.mozilla.org/en-US/kb/firefox-enterprise-kiosk-mode Running FireFox without a desktop: https://linuxconfig.org/how-to-run-x-applications-without-a-desktop-or-a-wm Frontend requirementsThe frontend requirements are simple for this proof of concept, but must display the capabilities of the full system. There will be 3 views: System diagnostics Disk capacity Cpu usage Last reboot, boot time. IP address Etc. interesting system stats System MaintenanceThis is the screen used for system maintenance: Upgrades. Allow upload of an update file from a USB stick to update the Rust and Vuecode Reboot. A button to reboot the system. It should come back up in the application. Itwould be great if it could record the time it took from pressing this button to being fullyrebooted, store that in the db for display in the diagnostics screen. Shoot for &amp;lt; 10s Reset database. A button to remove all user data from the database, essentially afactory reset. Data and operationsThis varies from application to application so this can be something creative. The requirementsare simply to be showing values read from the database, and some mechanism to change andadd those values. A suggestion is some ability to schedule a ‘task’, have the system update anddisplay its progress and display the list of completed tasks. Anything else that reads/writes thedatabase is acceptable.Because we want to demonstrate the performance of the UI on this platform, it is advisable to use somemore complex elements; animation in the form of donut charts or a sliding navigation panel. There ishowever no need for things like video playback or webgl.Installation and upgrade requirementsThe initial provisioning of the system can be manual, meaning that all components are installed with anetwork connection step by step, not via an installer script or other automated mechanism. Onceprovisioned though, the system should be upgradable via its own interface (see the System Maintenancepage above). This process should be done by an untrained user, someone with no familiarity with Linuxor programming, and may not know what a file-path is. There should be a documented method ofcreating a USB stick (by technical personnel) that can be provided to the user. The user should be ableto insert this USB stick, press the upgrade button on the maintenance screen and somehow end up withan upgraded system. The version number should be visible on all screens.For this project, the upgrade does not have to handle database migrations (additions or modifications tothe PostgreSQL db), but it should be able to update the Vue.js code as well as the Rust code. As astretch goal, the system should be robust to old or garbage update files or even maliciously craftedones." }, { "title": "FreeBSD Research", "url": "/s22-ewco/posts/FreeBSD-Research/", "categories": "Research, OS", "tags": "freebsd, os", "date": "2022-01-20 22:00:00 -0700", "snippet": "As outlined in the “HMI Kiosk Problem Statement” post, a major constraint for our embedded web controller will bethe memory footprint. The hardware our product will run on is an x86 processor with 1GB RAM.ArchitectureFrom some preliminary research, i386 FreeBSD images have a smaller memory footprint than amd64 (aprox 64MB RAM). Since our testenvironment runs a 64bit Intel chip, we flashed the amd64 image, but it is worthwhile exploring the possibilityof using the i386 image given the ~100MB potential footprint reduction.The memory consumption on a bare-bones installation of FreeBSD on the OnLogic computer is as follows:usr@fbsd-onlogic:~ $ dmesg | grep memoryreal memory = 1073741824 (1024 MB)avail memory = 821465088 (783 MB)" }, { "title": "Meeting Minutes 01/20/22", "url": "/s22-ewco/posts/Meeting-Minutes-01-20-22/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-01-20 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, DanielAbsent: No oneScribe: DevynItems: Worked on the Project Plan Draft, continued communication with the sponsors and got the meeting planned, and got the repo set up with the company. Obtained thehardware system from GoWest and finished setting up the hypervisor to begin overhead testing.A/I: Devyn - continue researching Rust before the sponsor meeting, work on the project plan draft. Mateo - Finish setting up the Hypervisor and finishing the ssh protocolsto allow us access, continue work on the project plan draft. Daniel - Continue work on the Project Plan Draft" }, { "title": "Meeting Minutes 01/18/22", "url": "/s22-ewco/posts/Meeting-Minutes-01-18-22/", "categories": "Logs, Meeting Minutes", "tags": "meeting, minutes", "date": "2022-01-18 07:00:00 -0700", "snippet": "Present: Devyn, Mateo, DanielAbsent: No oneScribe: DevynItems: Discussed our team name, set up our weekly meeting times and the main focus of the meeting was drafting the sponsor email to our points of contact in the company.A/I: Devyn - make first contact with sponsor via email. Mateo - Continue to set up CI/CD as well as any other scaffolding we think we need.Daniel - Begin researching Rust" } ]
